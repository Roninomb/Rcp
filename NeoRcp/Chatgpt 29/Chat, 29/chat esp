// === NeoRCP ESP32 (NimBLE) ===
// Env√≠a ACK al START, ticks cada 1s y JSON final por Notify (con \n).
// Reintenta 3 veces el notify final. Duraci√≥n de test: 5s.
// Librer√≠a: NimBLE-Arduino

#include <NimBLEDevice.h>
#include <math.h>

// -------- Pines --------
const int botonPin  = 35;   // ‚ö†Ô∏è requiere pull-up externo (mejor 32/33/25/26)
const int sensorPin = 34;

// -------- Par√°metros entrenamiento --------
int estadoBotonActual   = HIGH;
int estadoBotonAnterior = HIGH;
float PrimeraCompresion = 1;
unsigned long tiempoAnterior = 0;
unsigned long ultimoCambio   = 0;

const unsigned long intervaloMin  = 450;
const unsigned long intervaloMax  = 650;
const unsigned long debounceDelay = 50;

// ‚è±Ô∏è Test r√°pido (luego cambi√° a 20000)
const unsigned long DURACION_MS = 5000;

int compresionesTotales = 0;
int ritmoCorrecto       = 0;
int fuerzaCorrecta      = 0;

unsigned long tiempoInicio   = 0;
bool entrenamientoIniciado   = false;
bool entrenamientoFinalizado = false;

bool presionado      = false;
bool fuerzaDetectada = false;
bool fuerzaLiberada  = false;

unsigned long ultimoTick = 0;

// -------- BLE UUIDs (coinciden con la app) --------
#define SVC_UUID "f0000001-0451-4000-b000-000000000000"
#define RX_UUID  "f0000002-0451-4000-b000-000000000000" // Write
#define TX_UUID  "f0000003-0451-4000-b000-000000000000" // Notify

NimBLEServer*         g_server  = nullptr;
NimBLECharacteristic* g_txChar  = nullptr;
bool g_deviceConnected = false;

// -------- Utilidades --------
void resetEntrenamiento() {
  compresionesTotales = 0;
  ritmoCorrecto       = 0;
  fuerzaCorrecta      = 0;
  tiempoAnterior      = 0;
  ultimoCambio        = 0;
  presionado          = false;
  fuerzaDetectada     = false;
  fuerzaLiberada      = false;
  ultimoTick          = 0;
}

void bleNotifyLine(const String& s) {
  if (!g_txChar) return;
  String line = s.endsWith("\n") ? s : (s + "\n");
  int subs = g_txChar->getSubscribedCount();
  Serial.printf("üîî notify len=%d subs=%d conn=%d\n", line.length(), subs, (int)g_deviceConnected);
  g_txChar->setValue((uint8_t*)line.c_str(), line.length());
  g_txChar->notify();
}

void sendAckStart() {
  bleNotifyLine("{\"ack\":\"start\"}");
  Serial.println("üì§ ACK START enviado");
}

void iniciarEntrenamiento() {
  entrenamientoIniciado   = true;
  entrenamientoFinalizado = false;
  resetEntrenamiento();
  tiempoInicio = millis();
  Serial.println("üîÅ Entrenamiento iniciado");
}

void enviarJsonFinalYTerminar() {
  entrenamientoFinalizado = true;
  entrenamientoIniciado   = false;

  float comp2     = compresionesTotales - PrimeraCompresion;
  float pctRitmo  = (comp2 > 0) ? (ritmoCorrecto  * 100.0f / comp2) : 0.0f;
  float pctFuerza = (compresionesTotales > 0) ? (fuerzaCorrecta * 100.0f / compresionesTotales) : 0.0f;

  int  fuerzaPct = (int)roundf(pctFuerza);
  bool ritmoOK   = (pctRitmo >= 60.0f);

  String json = String("{")
                + "\"fuerza\":\""  + String(fuerzaPct)           + "\","
                + "\"pulsos\":\""  + String(compresionesTotales) + "\","
                + "\"ritmo\":\""   + String(ritmoOK ? "true" : "false") + "\""
                + "}";

  Serial.println("üì§ JSON final:");
  Serial.println(json);

  // Reintenta 3 veces por seguridad
  for (int i = 0; i < 3; ++i) {
    Serial.printf("üîÅ Notificando resultado (intento %d)\n", i + 1);
    bleNotifyLine(json);
    delay(120);
  }
}

// -------- Callbacks BLE --------
class ServerCB : public NimBLEServerCallbacks {
  void onConnect(NimBLEServer* pServer) override {
    g_deviceConnected = true;
    Serial.println("‚úÖ Central conectada");
  }
  void onDisconnect(NimBLEServer* pServer) override {
    g_deviceConnected = false;
    Serial.println("üö™ Central desconectada. Re-Advertising‚Ä¶");
    NimBLEDevice::startAdvertising();
  }
};

class RxCB : public NimBLECharacteristicCallbacks {
  void onWrite(NimBLECharacteristic* pCharacteristic) override {
    std::string v = pCharacteristic->getValue();
    if (v.empty()) return;
    String cmd;
    for (char ch : v) cmd += ch;
    cmd.trim(); cmd.toUpperCase();

    Serial.print("üì• CMD: "); Serial.println(cmd);

    if (cmd == "START") {
      sendAckStart();
      iniciarEntrenamiento();
    } else if (cmd == "STOP") {
      entrenamientoIniciado = false;
      entrenamientoFinalizado = true;
      Serial.println("‚õî STOP recibido");
    } else if (cmd == "TEST") {
      Serial.println("üß™ TEST -> JSON final inmediato");
      enviarJsonFinalYTerminar();
    }
  }
};

// -------- Setup BLE --------
void setupBLE() {
  NimBLEDevice::init("NeoRCP");
  NimBLEDevice::setPower(ESP_PWR_LVL_P7);
  NimBLEDevice::setMTU(185);

  g_server = NimBLEDevice::createServer();
  g_server->setCallbacks(new ServerCB());

  NimBLEService* svc = g_server->createService(SVC_UUID);

  // TX: Notify + CCCD (indispensable para Android)
  g_txChar = svc->createCharacteristic(
      TX_UUID,
      NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::NOTIFY
  );
  g_txChar->addDescriptor(new NimBLE2902());

  // RX: Write (comandos)
  NimBLECharacteristic* rx = svc->createCharacteristic(
      RX_UUID,
      NIMBLE_PROPERTY::WRITE | NIMBLE_PROPERTY::WRITE_NR
  );
  rx->setCallbacks(new RxCB());

  svc->start();

  NimBLEAdvertising* adv = NimBLEDevice::getAdvertising();
  adv->addServiceUUID(SVC_UUID);
  adv->setName("NeoRCP");
  adv->enableScanResponse(true);
  adv->start();

  Serial.println("üì° Advertising iniciado: NeoRCP");
}

// -------- Arduino setup/loop --------
void setup() {
  Serial.begin(115200);
  pinMode(botonPin, INPUT_PULLUP); // ‚ö†Ô∏è 35 sin pull-up interno -> usar resistencia externa
  pinMode(sensorPin, INPUT);

  setupBLE();
  Serial.println("Listo. Mand√° START/TEST por BLE (o 'YA' por Serial).");
}

void loop() {
  // Debug por Serial
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n'); cmd.trim(); cmd.toUpperCase();
    if (cmd == "YA")  { sendAckStart(); iniciarEntrenamiento(); }
    if (cmd == "TEST"){ enviarJsonFinalYTerminar(); }
  }

  if (!entrenamientoIniciado || entrenamientoFinalizado) return;

  // Timeout del entrenamiento
  if (millis() - tiempoInicio >= DURACION_MS) {
    Serial.println("‚è±Ô∏è Timeout alcanzado, enviando JSON final");
    enviarJsonFinalYTerminar();
    return;
  }

  // Ticks de diagn√≥stico (1/s) -> ver√°s en Flutter como [BLE][notify] {"tick":"n"}
  if (millis() - ultimoTick >= 1000) {
    ultimoTick = millis();
    bleNotifyLine(String("{\"tick\":\"") + String((millis() - tiempoInicio) / 1000) + "\"}");
  }

  // --- L√≥gica de bot√≥n/sensor (no afecta al env√≠o final por timeout) ---
  unsigned long t = millis();
  estadoBotonActual = digitalRead(botonPin);
  int estadoSensor  = digitalRead(sensorPin);

  // Flanco de bajada (apretar)
  if (estadoBotonAnterior == HIGH && estadoBotonActual == LOW && (t - ultimoCambio) > debounceDelay) {
    ultimoCambio    = t;
    presionado      = true;
    fuerzaDetectada = false;
    fuerzaLiberada  = false;
  }

  if (presionado) {
    if (!fuerzaDetectada && estadoSensor == LOW)  fuerzaDetectada = true;
    if (fuerzaDetectada && !fuerzaLiberada && estadoSensor == HIGH) fuerzaLiberada = true;

    // Flanco de subida (soltar)
    if (estadoBotonAnterior == LOW && estadoBotonActual == HIGH && (t - ultimoCambio) > debounceDelay) {
      ultimoCambio = t;
      presionado   = false;
      compresionesTotales++;

      if (fuerzaDetectada && fuerzaLiberada) fuerzaCorrecta++;

      unsigned long intervalo = t - tiempoAnterior;
      if (intervalo >= intervaloMin && intervalo <= intervaloMax) ritmoCorrecto++;
      tiempoAnterior = t;
    }
  }

  estadoBotonAnterior = estadoBotonActual;
}
