// === NeoRCP ESP32 (NimBLE) ===
// Recibe "START" por BLE y, al terminar 20s, env√≠a JSON por Notify.
#include <NimBLEDevice.h>
#include <math.h>

// ---------------- Pines ----------------
const int botonPin  = 35;   // ‚ö† sin pull-up interno (usa resistencia externa o cambia a 32/33/25/26)
const int sensorPin = 34;

// ---------------- L√≥gica de entrenamiento ----------------
int estadoBotonActual   = HIGH;
int estadoBotonAnterior = HIGH;

float PrimeraCompresion = 1;
unsigned long tiempoAnterior = 0;
unsigned long ultimoCambio   = 0;

const unsigned long intervaloMin  = 450;   // ms
const unsigned long intervaloMax  = 650;   // ms
const unsigned long debounceDelay = 50;    // ms
const unsigned long DURACION_MS   = 20000; // 20 s

int compresionesTotales = 0;
int ritmoCorrecto       = 0;
int fuerzaCorrecta      = 0;

unsigned long tiempoInicio   = 0;
bool entrenamientoIniciado   = false;
bool entrenamientoFinalizado = false;

// Banderas por compresi√≥n
bool presionado      = false;
bool fuerzaDetectada = false;
bool fuerzaLiberada  = false;

// ---------------- BLE (UUIDs) ----------------
#define SVC_UUID "f0000001-0451-4000-b000-000000000000"
#define RX_UUID  "f0000002-0451-4000-b000-000000000000" // Write (App -> ESP32)
#define TX_UUID  "f0000003-0451-4000-b000-000000000000" // Notify (ESP32 -> App)

NimBLEServer*         g_server  = nullptr;
NimBLECharacteristic* g_txChar  = nullptr;
bool g_deviceConnected = false;

// Si llega START antes de que Android termine de suscribirse, guardamos un ACK pendiente
bool g_ackStartPendiente = false;

// ---------- Utils de notificaci√≥n ----------
void bleNotifyLine(const String& s) {
  if (!g_deviceConnected || g_txChar == nullptr) {
    Serial.println("‚ö†Ô∏è No hay central conectada o TX nulo; no se notifica.");
    return;
  }
  if (g_txChar->getSubscribedCount() == 0) {
    Serial.println("‚ö†Ô∏è A√∫n no hay suscriptores al TX (CCCD no habilitado).");
    return;
  }
  String line = s.endsWith("\n") ? s : (s + "\n");   // SIEMPRE '\n'
  g_txChar->setValue((uint8_t*)line.c_str(), line.length());
  g_txChar->notify();
}

void sendAckStart() {
  bleNotifyLine("{\"ack\":\"start\"}");
  Serial.println("üì§ ACK START enviado");
}

// ---------------- L√≥gica ----------------
void resetEntrenamiento() {
  compresionesTotales = 0;
  ritmoCorrecto       = 0;
  fuerzaCorrecta      = 0;
  tiempoAnterior      = 0;
  ultimoCambio        = 0;
  presionado          = false;
  fuerzaDetectada     = false;
  fuerzaLiberada      = false;
}

void iniciarEntrenamiento() {
  entrenamientoIniciado   = true;
  entrenamientoFinalizado = false;
  resetEntrenamiento();
  tiempoInicio = millis();
  Serial.println("üîÅ Entrenamiento iniciado: 20s");
}

void enviarJsonFinalYTerminar() {
  entrenamientoFinalizado = true;
  entrenamientoIniciado   = false;

  float comp2     = compresionesTotales - PrimeraCompresion;
  float pctRitmo  = (comp2 > 0) ? (ritmoCorrecto  * 100.0f / comp2) : 0.0f;
  float pctFuerza = (compresionesTotales > 0) ? (fuerzaCorrecta * 100.0f / compresionesTotales) : 0.0f;

  int  fuerzaPct = (int)roundf(pctFuerza);
  bool ritmoOK   = (pctRitmo >= 60.0f);

  String json = String("{")
                + "\"fuerza\":\""  + String(fuerzaPct)           + "\","
                + "\"pulsos\":\""  + String(compresionesTotales) + "\","
                + "\"ritmo\":\""   + String(ritmoOK ? "true" : "false") + "\""
                + "}";

  Serial.println("üì§ JSON final:");
  Serial.println(json);
  bleNotifyLine(json);
}

// ---------------- Callbacks BLE ----------------
class ServerCB : public NimBLEServerCallbacks {
  void onConnect(NimBLEServer* s, NimBLEConnInfo& info) override {
    g_deviceConnected = true;
    Serial.printf("‚úÖ Central conectada: %s\n", info.getAddress().toString().c_str());
  }
  void onDisconnect(NimBLEServer* s, NimBLEConnInfo& info, int reason) override {
    g_deviceConnected = false;
    Serial.println("üö™ Central desconectada. Re-Advertising‚Ä¶");
    NimBLEDevice::startAdvertising();
  }
};

// Para loguear suscripciones al TX (CCCD 0x2902)
class TxCB : public NimBLECharacteristicCallbacks {
  void onSubscribe(NimBLECharacteristic* c, NimBLEConnInfo& info, uint16_t subValue) override {
    Serial.printf("üì° TX subscribed from %s, value=0x%04x, subs=%d\n",
                  info.getAddress().toString().c_str(), subValue, c->getSubscribedCount());
    if (g_ackStartPendiente) {
      sendAckStart();
      g_ackStartPendiente = false;
    }
  }
};

class RxCB : public NimBLECharacteristicCallbacks {
  void onWrite(NimBLECharacteristic* c, NimBLEConnInfo& info) override {
    std::string v = c->getValue();
    if (v.empty()) return;
    String cmd; for (char ch: v) cmd += ch;
    cmd.trim(); cmd.toUpperCase();
    Serial.print("üì• CMD: "); Serial.println(cmd);

    if (cmd == "START") {
      // ACK si ya hay suscripci√≥n; si no, quedar√° pendiente y se manda en onSubscribe
      if (g_txChar && g_txChar->getSubscribedCount() > 0) {
        sendAckStart();
      } else {
        Serial.println("‚åõ ACK START pendiente (a√∫n sin suscriptores)");
        g_ackStartPendiente = true;
      }
      iniciarEntrenamiento();
    } else if (cmd == "STOP") {
      entrenamientoIniciado = false;
      entrenamientoFinalizado = true;
      Serial.println("‚õî STOP recibido");
    }
  }
};

// ---------------- Setup/Loop ----------------
void setupBLE() {
  NimBLEDevice::init("NeoRCP");
  NimBLEDevice::setPower(ESP_PWR_LVL_P7);
  NimBLEDevice::setMTU(185);

  g_server = NimBLEDevice::createServer();
  g_server->setCallbacks(new ServerCB());

  auto svc = g_server->createService(SVC_UUID);

  // TX: Notify (resultados) + CCCD (0x2902) y callback de suscripci√≥n
  g_txChar = svc->createCharacteristic(
      TX_UUID,
      NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::NOTIFY
  );
  g_txChar->addDescriptor(new NimBLE2902());  // ‚≠êÔ∏è permite que Android escriba el CCCD
  g_txChar->setCallbacks(new TxCB());

  // RX: Write (comandos)
  auto rx = svc->createCharacteristic(
      RX_UUID,
      NIMBLE_PROPERTY::WRITE | NIMBLE_PROPERTY::WRITE_NR
  );
  rx->setCallbacks(new RxCB());

  svc->start();

  NimBLEAdvertising* adv = NimBLEDevice::getAdvertising();
  adv->setName("NeoRCP");
  adv->addServiceUUID(SVC_UUID);
  adv->enableScanResponse(true);
  adv->start();

  Serial.println("üì° Advertising iniciado: NeoRCP");
}

void setup() {
  Serial.begin(115200);
  pinMode(botonPin, INPUT_PULLUP); // ‚ö† requiere pull-up externo en GPIO35
  pinMode(sensorPin, INPUT);
  setupBLE();
  Serial.println("Esperando START por BLE (o 'YA' por Serial).");
}

void loop() {
  // Debug por Serial
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n'); cmd.trim(); cmd.toUpperCase();
    if (cmd == "YA") iniciarEntrenamiento();
  }

  if (!entrenamientoIniciado || entrenamientoFinalizado) return;

  // Timeout
  if (millis() - tiempoInicio >= DURACION_MS) {
    enviarJsonFinalYTerminar();
    return;
  }

  unsigned long t = millis();
  estadoBotonActual = digitalRead(botonPin);
  int estadoSensor  = digitalRead(sensorPin);

  // Flanco de bajada
  if (estadoBotonAnterior == HIGH && estadoBotonActual == LOW && (t - ultimoCambio) > debounceDelay) {
    ultimoCambio    = t;
    presionado      = true;
    fuerzaDetectada = false;
    fuerzaLiberada  = false;
  }

  if (presionado) {
    if (!fuerzaDetectada && estadoSensor == LOW)  fuerzaDetectada = true;
    if (fuerzaDetectada && !fuerzaLiberada && estadoSensor == HIGH) fuerzaLiberada = true;

    // Flanco de subida
    if (estadoBotonAnterior == LOW && estadoBotonActual == HIGH && (t - ultimoCambio) > debounceDelay) {
      ultimoCambio = t;
      presionado   = false;
      compresionesTotales++;

      if (fuerzaDetectada && fuerzaLiberada) fuerzaCorrecta++;

      unsigned long intervalo = t - tiempoAnterior;
      if (intervalo >= intervaloMin && intervalo <= intervaloMax) ritmoCorrecto++;
      tiempoAnterior = t;
    }
  }

  estadoBotonAnterior = estadoBotonActual;
}
