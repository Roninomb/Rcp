// === NeoRCP ESP32 (NimBLE) ===
// Recibe "START" por BLE y, al terminar, env√≠a JSON final por Notify.
// Incluye: CCCD 0x2902, ACK de START, ticks por segundo y 3 reintentos del notify final.
// Librer√≠a: NimBLE-Arduino (https://github.com/h2zero/NimBLE-Arduino)

#include <NimBLEDevice.h>
#include <math.h>

// ---------------- Pines ----------------
const int botonPin  = 35;   // ‚ö†Ô∏è requiere pull-up externo (mejor usar 32/33/25/26)
const int sensorPin = 34;   // fuerza: LOW/HIGH

// ---------------- Par√°metros entrenamiento ----------------
int estadoBotonActual   = HIGH;
int estadoBotonAnterior = HIGH;

float PrimeraCompresion   = 1;
unsigned long tiempoAnterior = 0;
unsigned long ultimoCambio   = 0;

// Ventana de ritmo correcto
const unsigned long intervaloMin  = 450;   // ms
const unsigned long intervaloMax  = 650;   // ms
const unsigned long debounceDelay = 50;    // ms

// ‚è±Ô∏è Duraci√≥n (para test est√° en 5 s; luego ponelo en 20000)
const unsigned long DURACION_MS   = 5000;  // 20_000 en producci√≥n

int compresionesTotales = 0;
int ritmoCorrecto       = 0;
int fuerzaCorrecta      = 0;

unsigned long tiempoInicio   = 0;
bool entrenamientoIniciado   = false;
bool entrenamientoFinalizado = false;

// Banderas por compresi√≥n
bool presionado      = false;
bool fuerzaDetectada = false;
bool fuerzaLiberada  = false;

// Tick de diagn√≥stico
unsigned long ultimoTick = 0;

// ---------------- BLE (UUIDs deben coincidir con la app) ----------------
#define SVC_UUID "f0000001-0451-4000-b000-000000000000"
#define RX_UUID  "f0000002-0451-4000-b000-000000000000" // Write (App -> ESP32)
#define TX_UUID  "f0000003-0451-4000-b000-000000000000" // Notify (ESP32 -> App)

NimBLEServer*         g_server   = nullptr;
NimBLECharacteristic* g_txChar   = nullptr;
bool                  g_deviceConnected = false;

// ---------------- Utilidades ----------------
void resetEntrenamiento() {
  compresionesTotales = 0;
  ritmoCorrecto       = 0;
  fuerzaCorrecta      = 0;
  tiempoAnterior      = 0;
  ultimoCambio        = 0;
  presionado          = false;
  fuerzaDetectada     = false;
  fuerzaLiberada      = false;
  ultimoTick          = 0;
}

void iniciarEntrenamiento() {
  entrenamientoIniciado   = true;
  entrenamientoFinalizado = false;
  resetEntrenamiento();
  tiempoInicio = millis();
  Serial.println("üîÅ Entrenamiento iniciado");
}

void bleNotifyLine(const String& s) {
  if (!g_txChar) {
    Serial.println("‚ö†Ô∏è TX char nula, no se notifica");
    return;
  }
  String line = s.endsWith("\n") ? s : (s + "\n");
  int subs = g_txChar->getSubscribedCount();
  Serial.printf("üîî notify(len=%d) subs=%d connected=%d\n",
                line.length(), subs, (int)g_deviceConnected);
  g_txChar->setValue((uint8_t*)line.c_str(), line.length());
  g_txChar->notify(); // no bloqueamos si subs==0 (para test).
}

void sendAckStart() {
  bleNotifyLine("{\"ack\":\"start\"}");
  Serial.println("üì§ ACK START enviado");
}

void enviarJsonFinalYTerminar() {
  entrenamientoFinalizado = true;
  entrenamientoIniciado   = false;

  float comp2     = compresionesTotales - PrimeraCompresion;
  float pctRitmo  = (comp2 > 0) ? (ritmoCorrecto  * 100.0f / comp2) : 0.0f;
  float pctFuerza = (compresionesTotales > 0) ? (fuerzaCorrecta * 100.0f / compresionesTotales) : 0.0f;

  int  fuerzaPct = (int)roundf(pctFuerza);
  bool ritmoOK   = (pctRitmo >= 60.0f);

  String json = String("{")
                + "\"fuerza\":\""  + String(fuerzaPct)           + "\","
                + "\"pulsos\":\""  + String(compresionesTotales) + "\","
                + "\"ritmo\":\""   + String(ritmoOK ? "true" : "false") + "\""
                + "}";

  Serial.println("üì§ JSON final:");
  Serial.println(json);

  // Reintentos por si la primera notificaci√≥n no llega
  for (int i = 0; i < 3; ++i) {
    Serial.printf("üîÅ Notificando resultado (intento %d)\n", i + 1);
    bleNotifyLine(json);
    delay(120);
  }
}

// ---------------- Callbacks BLE ----------------
class ServerCB : public NimBLEServerCallbacks {
  void onConnect(NimBLEServer* pServer) override {
    g_deviceConnected = true;
    Serial.println("‚úÖ Central conectada");
  }
  void onDisconnect(NimBLEServer* pServer) override {
    g_deviceConnected = false;
    Serial.println("üö™ Central desconectada. Re-Advertising‚Ä¶");
    NimBLEDevice::startAdvertising();
  }
};

class RxCB : public NimBLECharacteristicCallbacks {
  void onWrite(NimBLECharacteristic* pCharacteristic) override {
    std::string v = pCharacteristic->getValue();
    if (v.empty()) return;
    String cmd;
    for (char ch : v) cmd += ch;
    cmd.trim(); cmd.toUpperCase();

    Serial.print("üì• CMD: "); Serial.println(cmd);

    if (cmd == "START") {
      sendAckStart();      // confirma camino de notify
      iniciarEntrenamiento();
    } else if (cmd == "STOP") {
      entrenamientoIniciado = false;
      entrenamientoFinalizado = true;
      Serial.println("‚õî STOP recibido");
    } else if (cmd == "TEST") {
      Serial.println("üß™ TEST -> enviando JSON final inmediato");
      enviarJsonFinalYTerminar();
    }
  }
};

// ---------------- Setup BLE ----------------
void setupBLE() {
  NimBLEDevice::init("NeoRCP");
  NimBLEDevice::setPower(ESP_PWR_LVL_P7);
  NimBLEDevice::setMTU(185);

  g_server = NimBLEDevice::createServer();
  g_server->setCallbacks(new ServerCB());

  NimBLEService* svc = g_server->createService(SVC_UUID);

  // TX: Notify + CCCD
  g_txChar = svc->createCharacteristic(
      TX_UUID,
      NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::NOTIFY
  );
  g_txChar->addDescriptor(new NimBLE2902()); // permite que Android habilite notificaciones

  // RX: Write (comandos)
  NimBLECharacteristic* rx = svc->createCharacteristic(
      RX_UUID,
      NIMBLE_PROPERTY::WRITE | NIMBLE_PROPERTY::WRITE_NR
  );
  rx->setCallbacks(new RxCB());

  svc->start();

  NimBLEAdvertising* adv = NimBLEDevice::getAdvertising();
  adv->addServiceUUID(SVC_UUID);
  adv->setName("NeoRCP");
  adv->enableScanResponse(true);
  adv->start();

  Serial.println("üì° Advertising iniciado: NeoRCP");
}

// ---------------- Arduino setup/loop ----------------
void setup() {
  Serial.begin(115200);
  pinMode(botonPin, INPUT_PULLUP); // ‚ö†Ô∏è 35 no tiene pull-up interno: usar resistencia externa
  pinMode(sensorPin, INPUT);

  setupBLE();
  Serial.println("Listo. Enviar START/TEST por BLE (o 'YA' por Serial).");
}

void loop() {
  // Debug por Serial
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n'); cmd.trim(); cmd.toUpperCase();
    if (cmd == "YA") {
      sendAckStart();
      iniciarEntrenamiento();
    } else if (cmd == "TEST") {
      enviarJsonFinalYTerminar();
    }
  }

  if (!entrenamientoIniciado || entrenamientoFinalizado) return;

  // Timeout de entrenamiento
  if (millis() - tiempoInicio >= DURACION_MS) {
    Serial.println("‚è±Ô∏è Timeout alcanzado, enviando JSON final");
    enviarJsonFinalYTerminar();
    return;
  }

  // Ticks de diagn√≥stico (1/s)
  if (millis() - ultimoTick >= 1000) {
    ultimoTick = millis();
    bleNotifyLine(String("{\"tick\":\"") + String((millis() - tiempoInicio) / 1000) + "\"}");
  }

  unsigned long t = millis();
  estadoBotonActual = digitalRead(botonPin);
  int estadoSensor  = digitalRead(sensorPin);

  // Flanco de bajada (apretar)
  if (estadoBotonAnterior == HIGH && estadoBotonActual == LOW && (t - ultimoCambio) > debounceDelay) {
    ultimoCambio    = t;
    presionado      = true;
    fuerzaDetectada = false;
    fuerzaLiberada  = false;
  }

  if (presionado) {
    if (!fuerzaDetectada && estadoSensor == LOW)  fuerzaDetectada = true;   // fuerza aplicada
    if (fuerzaDetectada && !fuerzaLiberada && estadoSensor == HIGH) fuerzaLiberada = true; // liberada

    // Flanco de subida (soltar)
    if (estadoBotonAnterior == LOW && estadoBotonActual == HIGH && (t - ultimoCambio) > debounceDelay) {
      ultimoCambio = t;
      presionado   = false;
      compresionesTotales++;

      if (fuerzaDetectada && fuerzaLiberada) {
        fuerzaCorrecta++;
      }

      unsigned long intervalo = t - tiempoAnterior;
      if (intervalo >= intervaloMin && intervalo <= intervaloMax) {
        ritmoCorrecto++;
      }
      tiempoAnterior = t;
    }
  }

  estadoBotonAnterior = estadoBotonActual;
}
